
/** X-TRADER FRONTEND - final9 (auto-update + ad-refresh optimized) **/
const API_BASE = "http://localhost:5000";
const REFRESH_MIN = 5;               // 5-minute cadence info-only
const POLL_MS = 3000;                // long-poll (ms)
const STREAM_URL = API_BASE + "/api/stream";

// ---- i18n (unchanged texts) ----
const baseEN = {
  signals_title: "Latest signals (live)",
  signals_desc: "AI trading signals, synchronized every 5 minutes, for operations up to ~2 hours, designed for Binance.",
  tbl_pair: "Pair",
  tbl_signal: "Signal",
  tbl_time: "Time (UTC)",
  loading: "Loadingâ€¦",
  panel_status_title: "AI system status",
  panel_status_offline: "Offline",
  panel_status_desc_online: "AI is running and sending signals",
  info_title: "âš¡ Signal info",
  info_body: "Signals are generated by your AI system and update automatically as new data arrives.",
  footer_note: "AI signals, no financial advice."
};

const ALL_LANGS = [
  ["en","ðŸ‡ºðŸ‡¸ English"],["zh","ðŸ‡¨ðŸ‡³ ä¸­æ–‡"],["es","ðŸ‡ªðŸ‡¸ EspaÃ±ol"],["hi","ðŸ‡®ðŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€"],["ar","ðŸ‡¸ðŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"],
  ["fr","ðŸ‡«ðŸ‡· FranÃ§ais"],["bn","ðŸ‡§ðŸ‡© à¦¬à¦¾à¦‚à¦²à¦¾"],["pt","ðŸ‡µðŸ‡¹ PortuguÃªs"],["ru","ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹"],["ur","ðŸ‡µðŸ‡° Ø§Ø±Ø¯Ùˆ"],
  ["id","ðŸ‡®ðŸ‡© Bahasa"],["de","ðŸ‡©ðŸ‡ª Deutsch"],["ja","ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž"],["sw","ðŸ‡°ðŸ‡ª Kiswahili"],["tr","ðŸ‡¹ðŸ‡· TÃ¼rkÃ§e"],
  ["ko","ðŸ‡°ðŸ‡· í•œêµ­ì–´"],["it","ðŸ‡®ðŸ‡¹ Italiano"],["fa","ðŸ‡®ðŸ‡· ÙØ§Ø±Ø³ÛŒ"],["ha","ðŸ‡³ðŸ‡¬ Hausa"],["vi","ðŸ‡»ðŸ‡³ Tiáº¿ng Viá»‡t"],
  ["th","ðŸ‡¹ðŸ‡­ à¹„à¸—à¸¢"],["pl","ðŸ‡µðŸ‡± Polski"],["uk","ðŸ‡ºðŸ‡¦ Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°"],["ro","ðŸ‡·ðŸ‡´ RomÃ¢nÄƒ"],["nl","ðŸ‡³ðŸ‡± Nederlands"],
  ["el","ðŸ‡¬ðŸ‡· Î•Î»Î»Î·Î½Î¹ÎºÎ¬"],["cs","ðŸ‡¨ðŸ‡¿ ÄŒeÅ¡tina"],["hu","ðŸ‡­ðŸ‡º Magyar"],["he","ðŸ‡®ðŸ‡± ×¢×‘×¨×™×ª"],["sv","ðŸ‡¸ðŸ‡ª Svenska"],
  ["ta","ðŸ‡®ðŸ‡³ à®¤à®®à®¿à®´à¯"],["te","ðŸ‡®ðŸ‡³ à°¤à±†à°²à±à°—à±"],["mr","ðŸ‡®ðŸ‡³ à¤®à¤°à¤¾à¤ à¥€"],["gu","ðŸ‡®ðŸ‡³ àª—à«àªœàª°àª¾àª¤à«€"],["pa","ðŸ‡®ðŸ‡³ à¨ªà©°à¨œà¨¾à¨¬à©€"],
  ["yo","ðŸ‡³ðŸ‡¬ YorÃ¹bÃ¡"],["my","ðŸ‡²ðŸ‡² á€™á€¼á€”á€ºá€™á€¬"],["zu","ðŸ‡¿ðŸ‡¦ isiZulu"],["am","ðŸ‡ªðŸ‡¹ áŠ áˆ›áˆ­áŠ›"],["ms","ðŸ‡²ðŸ‡¾ Bahasa Melayu"]
];

const BINANCE_PHRASE = {
  en: "designed for Binance.", it: "studiato per Binance.", es: "diseÃ±ado para Binance.",
  fr: "conÃ§u pour Binance.", de: "entwickelt fÃ¼r Binance.", pt: "desenvolvido para a Binance.",
  ru: "Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾ Ð´Ð»Ñ Binance.", ar: "Ù…ØµÙ…Ù… Ù„Ù…Ù†ØµØ© Binance.", hi: "Binance à¤•à¥‡ à¤²à¤¿à¤ à¤¤à¥ˆà¤¯à¤¾à¤° à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾.",
  zh: "ä¸º Binance ä¼˜åŒ–ã€‚", id: "dirancang untuk Binance.", tr: "Binance iÃ§in tasarlanmÄ±ÅŸtÄ±r.",
  ko: "Binanceìš©ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.", ja: "Binance å‘ã‘ã«æœ€é©åŒ–ã€‚", sw: "iliyoundwa kwa Binance.",
  fa: "Ø·Ø±Ø§Ø­ÛŒâ€ŒØ´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Binance.", ha: "an tsara shi don Binance.", vi: "Ä‘Æ°á»£c thiáº¿t káº¿ cho Binance.",
  th: "à¸­à¸­à¸à¹à¸šà¸šà¸¡à¸²à¸ªà¸³à¸«à¸£à¸±à¸š Binance", pl: "zaprojektowane dla Binance.", uk: "Ñ€Ð¾Ð·Ñ€Ð¾Ð±Ð»ÐµÐ½Ð¾ Ð´Ð»Ñ Binance.",
  ro: "conceput pentru Binance.", nl: "ontworpen voor Binance.", el: "ÏƒÏ‡ÎµÎ´Î¹Î±ÏƒÎ¼Î­Î½Î¿ Î³Î¹Î± Ï„Î¿ Binance.",
  cs: "navrÅ¾eno pro Binance.", hu: "a Binance szÃ¡mÃ¡ra kÃ©szÃ¼lt.", he: "×©× ×•×¢×“ ×¢×‘×•×¨ Binance.",
  sv: "utformat fÃ¶r Binance.", ta: "Binance à®•à¯à®•à®¾à®• à®µà®Ÿà®¿à®µà®®à¯ˆà®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯.", te: "Binance à°•à±‹à°¸à°‚ à°°à±‚à°ªà±à°¦à°¿à°¦à±à°¦à±à°•à±à°‚à°¦à°¿.",
  mr: "Binance à¤¸à¤¾à¤ à¥€ à¤¤à¤¯à¤¾à¤° à¤•à¥‡à¤²à¥‡à¤²à¥‡.", gu: "Binance àª®àª¾àªŸà«‡ àª¬àª¨àª¾àªµàª¾àª¯à«àª‚ àª›à«‡.", pa: "à¨œà©‹ Binance à¨²à¨ˆ à¨¬à¨£à¨¾à¨‡à¨† à¨—à¨¿à¨† à¨¹à©ˆ.",
  yo: "tÃ­ a á¹£e fÃºn Binance.", my: "Binance á€¡á€á€½á€€á€º á€’á€®á€‡á€­á€¯á€„á€ºá€¸á€œá€¯á€•á€ºá€‘á€¬á€¸á€žá€Šá€ºá‹", zu: "eyiklanyelwe i-Binance.",
  am: "áˆˆ Binance á‹¨á‰°á‹˜áŒ‹áŒ€ áŠá‹á¢", ms: "direka untuk Binance.", bn: "Binance à¦à¦° à¦œà¦¨à§à¦¯ à¦¤à§ˆà¦°à¦¿à¥¤"
};

const LANGS = {};
ALL_LANGS.forEach(([code]) => {
  LANGS[code] = { ...baseEN };
  const addon = BINANCE_PHRASE[code] || BINANCE_PHRASE.en;
  if (code==="zh"){
    Object.assign(LANGS[code], {
      signals_title:"æœ€æ–°ä¿¡å·ï¼ˆå®žæ—¶ï¼‰", tbl_pair:"äº¤æ˜“å¯¹", tbl_signal:"ä¿¡å·", tbl_time:"æ—¶é—´ (UTC)",
      loading:"åŠ è½½ä¸­â€¦", panel_status_title:"AI ç³»ç»ŸçŠ¶æ€", panel_status_offline:"ç¦»çº¿",
      panel_status_desc_online:"AI æ­£åœ¨è¿è¡Œå¹¶å‘é€ä¿¡å·", info_title:"âš¡ ä¿¡å·è¯´æ˜Ž",
      info_body:"ä¿¡å·ç”±ä½ çš„ AI ç³»ç»Ÿç”Ÿæˆï¼Œå¹¶åœ¨æœ‰æ–°æ•°æ®æ—¶è‡ªåŠ¨æ›´æ–°ã€‚", footer_note:"AI ä¿¡å·ï¼Œä»…ä¾›å‚è€ƒã€‚"
    });
    LANGS[code].signals_desc = "AI äº¤æ˜“ä¿¡å·ï¼Œæ¯ 5 åˆ†é’ŸåŒæ­¥ä¸€æ¬¡ï¼Œé€‚ç”¨äºŽæœ€é•¿çº¦ 2 å°æ—¶çš„äº¤æ˜“ï¼Œ" + addon;
  } else if (code==="es"){
    Object.assign(LANGS[code], {
      signals_title:"Ãšltimas seÃ±ales (en vivo)", tbl_pair:"Par", tbl_signal:"SeÃ±al", tbl_time:"Hora (UTC)",
      loading:"Cargandoâ€¦", panel_status_title:"Estado del sistema IA", panel_status_offline:"Offline",
      panel_status_desc_online:"La IA estÃ¡ activa y enviando seÃ±ales", info_title:"âš¡ Info de seÃ±ales",
      info_body:"Las seÃ±ales son generadas por tu sistema de IA y se actualizan automÃ¡ticamente cuando llega nuevo dato."
    });
    LANGS[code].signals_desc = "SeÃ±ales de trading con IA, sincronizadas cada 5 minutos, para operaciones de hasta ~2 horas, " + addon;
  } else if (code==="it"){
    Object.assign(LANGS[code], {
      signals_title:"Ultimi segnali (live)", tbl_pair:"Coppia", tbl_signal:"Segnale", tbl_time:"Orario (UTC)",
      loading:"Caricamentoâ€¦", panel_status_title:"Stato sistema AI", panel_status_offline:"Offline",
      panel_status_desc_online:"Il sistema AI Ã¨ attivo e sta inviando segnali", info_title:"âš¡ Info segnali",
      info_body:"I segnali sono generati dal tuo sistema AI e si aggiornano automaticamente all'arrivo di nuovi dati."
    });
    LANGS[code].signals_desc = "Segnali di trading AI, sincronizzati ogni 5 minuti, per operazioni fino a ~2 ore, " + addon;
  } else {
    LANGS[code].signals_desc = "AI trading signals, synchronized every 5 minutes, for operations up to ~2 hours, " + addon;
  }
});

// ---- Language selector ----
const langSelect = document.getElementById("langSwitcher");
if (langSelect) {
  ALL_LANGS.forEach(([code,label]) => {
    const o = document.createElement("option");
    o.value = code; o.textContent = label;
    if (code === "en") o.selected = true;
    langSelect.appendChild(o);
  });
  const saved = localStorage.getItem("xtrader_lang");
  if (saved && LANGS[saved]) { langSelect.value = saved; applyLang(saved); } else { applyLang("en"); }
  langSelect.addEventListener("change", e => {
    const lang = e.target.value; applyLang(lang); localStorage.setItem("xtrader_lang", lang);
  });
} else { applyLang("en"); }

function applyLang(lang){
  const dict = LANGS[lang] || baseEN;
  document.querySelectorAll("[data-i18n]").forEach(el=>{
    const k = el.dataset.i18n; if (dict[k]) el.textContent = dict[k];
  });
}

// ---- Live signals (SSE with polling fallback) ----
let lastHash = null;
let etag = null;

// quick hash for change detection
function quickHash(obj){
  try { const s = JSON.stringify(obj); let h = 0; for (let i=0;i<s.length;i++){ h = (h*31 + s.charCodeAt(i)) > 0; } return h.toString(16); }
  catch(e){ return null; }
}

async function fetchLatest(){
  const headers = { "Cache-Control": "no-store" };
  if (etag) headers["If-None-Match"] = etag;
  const res = await fetch(API_BASE + "/api/latest", { headers });
  if (res.status === 304) return { changed:false };
  if (!res.ok) throw new Error("HTTP " + res.status);
  etag = res.headers.get("ETag") || etag;
  const data = await res.json();
  const h = quickHash(data);
  if (h !== lastHash) {
    lastHash = h;
    renderSignals(data); renderSignalCards(data);
    setBackendStatus(true);
    onSignalsUpdated(); // <-- trigger ads refresh on data change
    return { changed:true };
  }
  return { changed:false };
}

async function startLongPoll(){
  while (true){
    try { await fetchLatest(); await waitMs(3000); }
    catch(e){ setBackendStatus(false); await waitMs(10000); }
  }
}

function startSSE(){
  try {
    const es = new EventSource(STREAM_URL, { withCredentials:false });
    let opened = false;
    es.onopen = () => { opened = true; setBackendStatus(true); };
    es.onmessage = (ev) => {
      try{
        const data = JSON.parse(ev.data);
        const h = quickHash(data);
        if (h !== lastHash){
          lastHash = h;
          renderSignals(data); renderSignalCards(data);
          onSignalsUpdated(); // <-- trigger ads refresh
        }
      }catch(e){ /* ignore */ }
    };
    es.onerror = () => { es.close(); startLongPoll(); };
  } catch(e){ startLongPoll(); }
}

function waitMs(ms){ return new Promise(r=>setTimeout(r, ms)); }

// ---- Renderers ----
function renderSignals(list){
  const tbody = document.getElementById("signalRows");
  if(!tbody) return;
  tbody.innerHTML = "";
  const lang = getLang();
  if(!list || list.length===0){
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 3; td.textContent = LANGS[lang].loading;
    tr.appendChild(td); tbody.appendChild(tr); return;
  }
  list.forEach(item=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    const td3 = document.createElement("td");
    td1.textContent = item.pair || "-";
    const s = (item.signal||"").toUpperCase();
    td2.textContent = s;
    if (s==="BUY") td2.classList.add("signal-buy");
    else if (s==="SELL") td2.classList.add("signal-sell");
    else td2.classList.add("signal-hold");
    const ts = item.timestamp ? new Date(item.timestamp).toISOString().slice(0,19).replace("T"," ") : "-";
    td3.textContent = ts + " UTC";
    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
    tbody.appendChild(tr);
  });
}

function renderSignalCards(list){
  const wrap = document.getElementById("signalCards");
  if(!wrap) return; wrap.innerHTML = "";
  const lang = getLang();
  if(!list || list.length===0){
    const div = document.createElement("div");
    div.className = "signal-card";
    div.innerHTML = `
      <div class="pair">-</div>
      <div class="signal signal-hold">-</div>
      <div class="time">${LANGS[lang].loading}</div>
    `;
    wrap.appendChild(div); return;
  }
  list.slice(0,12).forEach(item=>{
    const s = (item.signal||"").toUpperCase();
    const card = document.createElement("div");
    card.className = "signal-card";
    const cls = s==="BUY" ? "signal-buy" : (s==="SELL" ? "signal-sell" : "signal-hold");
    const ts = item.timestamp ? new Date(item.timestamp).toISOString().slice(0,19).replace("T"," ") + " UTC" : "-";
    card.innerHTML = `
      <div class="pair">${item.pair || "-"}</div>
      <div class="signal ${cls}">${s || "-"}</div>
      <div class="time">${ts}</div>
    `;
    wrap.appendChild(card);
  });
}

function setBackendStatus(ok){
  const el = document.getElementById("backendStatus");
  const sub = document.getElementById("backendStatusSub");
  if(!el) return;
  const dict = LANGS[getLang()] || baseEN;
  if(ok){
    el.textContent = "Online";
    el.classList.remove("offline"); el.classList.add("online");
    if (sub) { sub.textContent = dict.panel_status_desc_online; sub.style.display = "inline"; }
  } else {
    el.textContent = dict.panel_status_offline;
    el.classList.remove("online"); el.classList.add("offline");
    if (sub) { sub.style.display = "none"; }
  }
}

function getLang(){ return (document.getElementById("langSwitcher") || {}).value || "en"; }

// ---- AD REFRESH (optimized, non-invasive, policy-friendly) ----
const MIN_SLOT_REFRESH_MS = 60000;   // >= 60s per slot
const PRE_WINDOW_MIN = 30000;        // 30s before next 5m tick
const PRE_WINDOW_MAX = 60000;        // up to 60s before

const adSlots = [
  { id: "ad-slot-1", last: 0 },
  { id: "ad-slot-2", last: 0 },
  { id: "ad-slot-3", last: 0 },
];

// Observe visibility (>=50% in view)
const visMap = {};
const io = new IntersectionObserver(entries=>{
  entries.forEach(e=>{ visMap[e.target.id] = e.isIntersecting; });
}, { threshold: 0.5 });
adSlots.forEach(s=>{
  const el = document.getElementById(s.id);
  if (el) io.observe(el);
});

function refreshAdSlotsInView(){
  adSlots.forEach(s=>{
    const el = document.getElementById(s.id);
    if (!el) return;
    const now = Date.now();
    if (now - s.last < MIN_SLOT_REFRESH_MS) return;
    if (visMap[s.id]) {
      refreshOneSlot(el);
      s.last = now;
    }
  });
}

// Generic refresh: supports image fallback and simple Coinzilla reinjection
function refreshOneSlot(el){
  const type = el.getAttribute("data-ad-type") || "image";
  if (type === "image"){
    const img = el.querySelector("img");
    if (img){
      const base = img.getAttribute("src").split("?")[0];
      img.setAttribute("src", base + "?cb=" + Date.now());
    }
    return;
  }
  if (type === "coinzilla"){
    const zone = el.getAttribute("data-coinzilla-zone");
    if (!zone) return;
    el.innerHTML = ""; // clear
    // Re-inject the tag script for this zone
    const s = document.createElement("script");
    s.src = "https://cdn.coinzilla.io/serve.js";
    s.setAttribute("data-zone", zone);
    el.appendChild(s);
    return;
  }
  // Custom handlers (e.g., GPT) can be attached here:
  if (window.adRefreshHandlers && typeof window.adRefreshHandlers[el.id] === "function"){
    try { window.adRefreshHandlers[el.id](el); } catch(e){}
  }
}

// Dispatch an immediate ad refresh (used on new signals + scheduled)
function dispatchAdRefreshNow(){
  refreshAdSlotsInView();
}

// Triggered when signals change
function onSignalsUpdated(){
  dispatchAdRefreshNow();
}

// Pre-refresh scheduler 30-60s before each 5-min boundary
function scheduleAdPreRefresh(){
  const now = new Date();
  const m = now.getMinutes();
  const next = Math.ceil(m/5)*5;
  const nextDate = new Date(now);
  nextDate.setMinutes(next, 0, 0);
  let diff = nextDate - now;
  if (diff <= 0) diff = 5*60*1000;
  const pre = Math.max(PRE_WINDOW_MIN, Math.min(PRE_WINDOW_MAX, diff - 5000));
  setTimeout(dispatchAdRefreshNow, pre);
  setTimeout(scheduleAdPreRefresh, diff + 1000);
}

// Periodic safety refresh (every 90s) - still in-view and per-slot throttled
setInterval(refreshAdSlotsInView, 90000);

// Kickoff
(async function initLive(){
  try { await fetchLatest(); } catch(e){ /* ignore */ }
  startSSE();
  scheduleAdPreRefresh();
})();
